/** \file definitions.h
	 \brief Definitions for libeegtools.
 */
#ifndef DEFINITIONS_H
#define DEFINITIONS_H

#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_wavelet.h>

/* replaced by autoconf */
#define @DEF_DEBUG@
#define @DEF_PLOTTER@
#define @DEF_MATIO@

#define ALLOC_IN_FCT NULL

#define MAX_LABEL_LENGTH 40

#define PROGRESSBAR_NUMCOLS        80 /**< number of columns for progress bar */
#define PROGRESSBAR_INIT           0  /**< initialize flag for progress bar   */
#define PROGRESSBAR_CONTINUE_SHORT 1  /**< continue flag for progress bar, minor step */
#define PROGRESSBAR_CONTINUE_LONG  2  /**< continue flag for progress bar, major step */
#define PROGRESSBAR_FINISH         3  /**< cleanup */

#ifdef __cplusplus
extern "C" { 
#else
 /*-----------------------------------------------------------
	 - CONVENIENCE -
	 we don't need (or may) declare this in C++, since there is
	 bool already
	 ---------------------------------------------------------*/
  typedef enum {
	 FALSE=0,
	 TRUE
  } bool;
#endif

#define SWAPT( Type, a, b ) { Type tmp; tmp=(a); (a)=(b); (b)=(tmp); }

  /* really long integer */
  typedef  unsigned long long ulonglong_t;

  /*-----------------------------------------------------------
	 -  slope constraint for DTW
	 ---------------------------------------------------------*/
  typedef enum {
	 SLOPE_CONSTRAINT_NONE=0,
	 SLOPE_CONSTRAINT_LAX,
	 SLOPE_CONSTRAINT_MEDIUM,
	 SLOPE_CONSTRAINT_SEVERE
  } SlopeConstraint;
  


  /*-----------------------------------------------------------
	 - EEG-CHANNELS -
	 ---------------------------------------------------------*/

  typedef struct{
	 int    num;
	 int    num_chans;
	 char   label[MAX_LABEL_LENGTH];
	 double x;
	 double y;
	 double z;
  } ChannelInfo;


  /*-----------------------------------------------------------
	 - EEG-Data -
	 ---------------------------------------------------------*/

  typedef struct{
	 char         *filename;
	 char         *comment;
	 unsigned int nbchan;  /**< number of channels */
	 unsigned int ntrials; /**< number of trials = dim(eeg) */ 
	 unsigned int n;       /**< number of samples */
    double       sampling_rate; /**< in Hz */
	 double       *times;  /**< times array; n-long */
	 ChannelInfo  *chaninfo; /**< location and other information
										 about the channels */

	 double       ***data; /**< channels x trials x samples */

	 unsigned int *nmarkers; /**< number of markers for each trial */
	 unsigned int **markers; /**< trials x nmarkers[i] */
	 char       ***marker_labels; /**< trials x nmarkers[i] x length(label) gives  a 
											  label for each marker */
  } EEG;

  
  /*-----------------------------------------------------------
	 - Optional Arguments
	 ---------------------------------------------------------*/
  /**\ingroup optarg
	*\{
	*/ 
  typedef struct {
	 char    key[MAX_LABEL_LENGTH];
	 bool    scalar;
	 char    type[MAX_LABEL_LENGTH];
	 void    *data_ptr;
	 double  data_scalar;
  } OptArg;

  typedef struct {
	 int nargs;
	 OptArg *args;
  } OptArgList;

  /*\}*/
  /*-----------------------------------------------------------
	 - Priority Queue
	 ---------------------------------------------------------*/

  struct pqueue {
	 double priority;
	 void *content;
	 struct pqueue *next;
  };
  typedef struct pqueue PQnode;

  typedef struct {
	 PQnode *root;
  } PriorityQueue;


  /*-----------------------------------------------------------
	 - Progress Bar
	 ---------------------------------------------------------*/
  typedef struct{
	 int max_progress;
	 int cur_progress;
	 int prev_progress;
  } ProgressBarStatus;

  /*-----------------------------------------------------------
	 - Nonlinear embedding -
	 ---------------------------------------------------------*/

  typedef struct {
	 int m;     /**< embedding dimension */
	 int tau;   /**< time-lag for embedding (>0, multiple of sampling_step) */
	 double *x; /**< pointer to data */
	 int xn;    /**< len(x) */
  } PhaseSpace;

  /*-----------------------------------------------------------
	 - Recurrence Plots - 
	 ---------------------------------------------------------*/

  /** Struct for representing recurrence or cross-recurrence plots.
		For recurrence plot, m=n.
		
		Depending on the settings of the struct, epsilon is fixed 
		or \f$ \epsilon = \epsilon(i)\f$ is chosen for each point on the 
		trajectory, such that there is a fixed amount of Neighbours. 
	*/
  typedef struct {
	 double **R;      /**< recurrence plot */
	 int m;           /**< first dim */
	 int n;           /**< second dim */
	 double fixed_epsilon;
	 double *epsilon; /**< ball in which neighbours are looked for */
	 int nepsilon;    /**< len(epsilon) */
	 int fan;         /**< fixed-amount of neighbours */
  } RecurrencePlot;



  /*-----------------------------------------------------------
	 - CLUSTERING -
	 ---------------------------------------------------------*/

  /**\ingroup clustering
	\{ */
  typedef struct{
	 int **clust; /** indices for the trials in the cluster (Kxn)*/
	 int K;       /** number of clusters */
	 int *n;      /** number of trials in each of the K clusters */
  } Clusters;


  /** This struct is the representation of a rooted binary tree to
	  hold a dendrogram. 
	  It is a terminal node if val>0 and left=right=NULL.
	  Else it is an intermediate node that has at least one child!=NULL.
	*/
   struct dgram {
	 int val;            /** content representing object val; if val<0, its an intermediate node */
	 double height;      /** proportional to between sub-cluster distance */
	 struct dgram *left;
	 struct dgram *right;
  };
  typedef struct dgram Dendrogram;
  /** \} */
  /*-----------------------------------------------------------
	 - Function Pointers
	 ---------------------------------------------------------*/
  typedef double**(*RegularizationFunction)       (double**,int,OptArgList*);
  typedef double  (*LinkageFunction)              (const double**,int,const Dendrogram*,const Dendrogram*);

  typedef double**(*PointwiseDistanceFunction)    (const double*,int,const double*,int,double**,OptArgList*);
  typedef double  (*VectorDistanceFunction)       (const double*,const double*,int,OptArgList*);
  typedef double  (*PointDistanceFunction)        (double,double);

  typedef double  (*ThresholdSelectionFunction)   (const double*,int);
  typedef double  (*ThresholdFunction)            (double,double);
  typedef double* (*SignalExtensionFunction)      (double*,int,int);

  typedef double* (*WindowFunction)               (double*,int);

  typedef void    (*ProgressBarFunction)          (int,int);

  /** \ingroup gap */
  typedef struct {
	 int K;            /**< maximum number of clusters */
	 int B;            /**< Monte-Carlo repetition of reference distr. calc. */
	 double *gapdistr; /**< final Gap-Statistic Distribution */
	 double *sk;       /**< modified standard deviation for gapdistr */
	 double *Wk;       /**< within scatter for data */
	 double **Wkref;   /**< within scatter for reference-dist */
	 int khat;         /**> best number of clusters */
	 ProgressBarFunction progress; /**> progress-bar callback */
  } GapStatistic;

  /*-----------------------------------------------------------
	 - Search Tree
	 ---------------------------------------------------------*/

  /**\cond PRIVATE */
  struct btree{
	 int c;     /* center */
	 double R;  /* maximal distance from c to any point */
	 double g;  /* min[ d(c,x)-d(sister,x) ] */
	 int start; /* start of cluster in A */
	 int end;   /* end of cluster in A */
	 double *cdist; /* distances from center for terminal nodes */
	 struct btree *left;
	 struct btree *right;
  };
  typedef struct btree TreeNode;
  /**\endcond */

  typedef struct {
	 int *A;       /**< index array */
	 const double **d;    /**< data pointer */
	 int m, N;      /**< dimensions of d */
	 VectorDistanceFunction distfct; /**< distance function */
	 TreeNode *root; /**< root node of the binary tree */
	 OptArgList *optargs;
  } SearchTree;


  /*-----------------------------------------------------------
	 - WARPING -
	 ---------------------------------------------------------*/

  typedef struct{
	 int *t1; /**< time-scale of first signal */
	 int *t2; /**< time-scale of second signal */
	 int n1; /**< length of signal 1 */
	 int n2; /**< length of signal 2 */
	 int n; /**< length(t1)==length(t2) */
  } WarpPath;
	

  /*-----------------------------------------------------------
	 - Wavelet-Denoising
	 ---------------------------------------------------------*/
  typedef struct {
	 int first_thresholding_level; /**< level to start thresholding on */
	 gsl_wavelet_type *wavelet;         /**< GSL-specification of wavelet */
	 int vanishing_moments;        /**< number of vanishing moments of the wavelet */
	 ThresholdSelectionFunction threshselfct; /**< function to select the threshold */
	 ThresholdFunction threshfct;             /**< hard/soft thresholding */
	 SignalExtensionFunction sigextfct;       /**< how to extend the signal to 2^K */
  } WaveletParameters;
  
  /*-----------------------------------------------------------
	 - Self-Organizing Maps (SOM)
	 ---------------------------------------------------------*/
  /** This is: distance = f( location of node i, location of node j, the model, current time );
	*/
  typedef double(*NeighbourhoodFunction)(int,int,struct som_struct*, int t);

  /** This is: alpha = f( t, nruns, nruns in initial_phase )
	*/
  typedef double(*TimeDecayFunction)(int,int,int);

  /**     giving the dimension/structure of the SOM:
   - 1D_LINEAR - 1-dimensional line, like 1<->2<->3<->...<->n
   - 2D_GRID - grid-like structure such that each node has 8 neighbours
   - 2D_HEXAGONAL
   - CUSTOM - you can define a custom connectivit matrix, where each entry [i,j]
              gives the distance between node i and j
  */
  typedef enum {
    ONED_LINEAR,
    TWOD_GRID,
    TWOD_HEXAGONAL,
    CUSTOM
  } SOMConnectivityType;

  /** Struct for 1-dimensional SOM with trivial topology 
		(neighbouring nodes).
	*/
  typedef struct som_struct {
	 double  **m; /**< code-book vectors */
	 int     dimension; /**< dimension of code-book vector (corresponds to data-dimensionality) */
	 int     n; /**< how many code-book vectors? */
	 VectorDistanceFunction distancefct; /**< distance measure between data and codebook-vectors */
	 void    *distancefct_parameters; /**< optional; pointer to parameters for some 
													 of the VectorDistanceFunction s */
	 
	 int     nruns; /**< number of runs to convergence */
	 int     initial_runs; /**< number of runs with large flexibility (ordering phase) after
									  which it is more restricted; e.g. 0.1*nruns */

	 NeighbourhoodFunction neighbourhoodfct; /**< neighbourhood function  */
	 TimeDecayFunction     time_decay; /**< function giving the decay of the 
													  learning rate */
	 SOMConnectivityType connectivity_type; /**< giving the dimension/structure of the SOM */
	 double **connectivity; /**< custom connectivity matrix that can implement
										an arbitrary topology for the SOM-network */

	 gsl_rng_type *random_number_type; /**< GSL-random number generator type */
	 gsl_rng *rng; /**< the GSL random number generator */

	 ProgressBarFunction progress; 
  } Som;


#ifdef __cplusplus
}
#endif

#endif
