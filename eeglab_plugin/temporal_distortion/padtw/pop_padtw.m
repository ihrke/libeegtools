% % pop_padtw() - Calculates an average taking temporal-distortion
%                 into account by hierarchically combining trials
%                 using dynamic time-warping.
%
% Usage:
%   >>  OUTEEG = pop_padtw( ALLEEG, EEG, 'key', 'value',...);
%
% Inputs:
%   INEEG   - input EEG dataset
%
% Opts:
%      - datasets      - list of datasets on which the average is to be
%                        computed. If empty, only EEG is computed, else the
%                        according indices from the ALLEEG-array.
%      - overwrite     - if the EEG-structs already have a EEG.padtw field,
%                        it is overwritten if overwrite is set to 1. Else it
%                        is reused.
%      - crosspadtw    - if set to one of {'padtw', avg'}, hierarchical
%                        DTW-average _across_ datasets is computed instead
%                        of calculating the PADTW for each dataset. 
%                        As data-basis for the cross-PADTW, either the
%                        single-dataset PADTW is used (crosspadtw=='padtw')
%                        if all the padtw-fields exist or the
%                        pointwise-average of the single trials can be used
%                        (crosspadtw=='avg') 
%      - chans         - array of channels for which the padtw is to be
%                        computed ([] means all channels)
%      - num_markers   - number of markers to be included in the
%                        regularization 
%      - markerlist    - list of valid markers that are to be included into
%                        the average. The function will search for markers
%                        in each ERP and use them if they are in
%                        'markerlist'. If not, they are dropped.
%      - regularize    - one of {'none', 'gaussian_markers'}. For 'none',
%                        no regularization is computed. For
%                        'gaussian_markers', a gaussian corridor with
%                        maximal std 'sigma' leading through 'num_markers'
%                        markers from 'markerlist' is used.
%      - sigma         - the standard deviation for the gaussian corridor
%                        in the regularization function
%      - linkage       - one of {'single', 'complete', 'average'};
%                        Linkage for the agglomerative cluster-algorithm
%                        that is used to calculate a dendrogram.
%      - pointdistance - one of {'euclidean', 'euclidean_derivative',
%                        'stft'}. This is the pointwise distance function
%                        used to calculate the path for the dynamic
%                        time-warping. If 'euclidean_derivative', 'theta'
%                        is used as weights to combine amplitude and
%                        slope. If 'stft', 'windowfct', 'winlength',
%                        'N_freq', 'N_time', 'corner_freqs' are used to
%                        calculate the spectrogram
%      - theta         - weights [theta1 theta2] used to combine
%                        amplitude and slope in the
%                        'euclidean_derivative' metric
%      - windowfct     - one of {'dirichlet', 'gaussian', 'hamming',
%                        'hanning', 'kaiser' }. This is the window
%                        function applied to the short-term FT in the
%                        'stft' distance metric
%      - winlength     - length of the window for the STFT
%      - N_freq        - frequency-resolution of the STFT (number of
%                        frequency bins)
%      - N_time        - time-resolution of the STFT (number of
%                        time bins)
%      - corner_freqs  - Corner-Frequencies for which the Spectrogram is
%                        used to calculate the pointwise distance
%                        'stft'. This is similar to bandpass-filtering
%                        the signal before calculating the spectrogram.
%      - progress      - [0|1] - should a progressbar be drawn?
%
%
% Outputs:
%   
%
% See also:
%   EEGLAB 

% Copyright (C) 2007  Matthias Ihrke <mihrke@uni-goettingen.de>
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
%
% $Log: pop_padtw.m,v $
% Revision 1.1  2009/05/05 20:43:06  mihrke
% fixed autotools issues
%
% Revision 1.1  2009/01/12 15:03:53  mihrke
% padtw eegplugin
%
%

function [com] = pop_padtw( ALLEEG, EEG, varargin );

% the command output is a hidden output that does not have to
% be described in the header

com = ''; % this initialization ensure that the function will return something
          % if the user press the cancel button            

% display help if not enough arguments
% ------------------------------------
if nargin < 1
	help pop_padtw;
	return;
end;	

% cmd-line parsing
args = varargin;
% create structure
% ----------------
if ~isempty(args)
   try, g = struct(args{:});
   catch, disp('pop_padtw(): wrong syntax in function arguments'); return; end;
else
    g = [];
end;

% test the presence of variables
% ------------------------------
try, g.datasets;           catch, g.datasets=[]; end;
try, g.overwrite;          catch, g.overwrite=1; end;
try, g.crosspadtw;         catch, g.crosspadtw=[]; end;
try, g.chans;              catch, g.chans=1:EEG.nbchan; end;
try, g.num_markers;        catch, g.num_markers=0; end;
try, g.markerlist;         catch, g.markerlist = {}; end;
try, g.regularize;         catch, g.regularize='none'; end;
try, g.sigma;              catch, g.sigma=0; end;
try, g.theta;              catch, g.theta=[1 1]; end;
try, g.corner_freqs;       catch, g.corner_freqs=[0 1]; end;
try, g.winlength;          catch, g.winlength=10; end;
try, g.N_freq;             catch, g.N_freq=10; end;
try, g.N_time;             catch, g.N_time=10; end;
try, g.linkage;            catch, g.linkage='complete'; end; 
try, g.windowfct;          catch, g.windowfct='gaussian'; end;
try, g.pointdistance;      catch, g.pointdistance='euclidean_derivative'; end;
try, g.progress;           catch, g.progress = 1; end;

assert(~isempty(EEG.epoch),[' Error: pop_padtw(): Hierarchical DTW ' ...
                    'can only be applied to epoched data']);

if nargin < 3
  cbevent = ['if ~isfield(EEG.event, ''type'')' ...
             '   errordlg2(''No type field'');' ...
             'else' ...
             '   if isnumeric(EEG.event(1).type),' ...
             '        [tmps,tmpstr] = pop_chansel(unique([ EEG.event.type ]));' ...
             '   else,' ...
             '        [tmps,tmpstr] = pop_chansel(unique({ EEG.event.type }));' ...
             '   end;' ...
             '   if ~isempty(tmps)' ...
             '       set(findobj(''parent'', gcbf, ''tag'', ''response_events''), ''string'', tmpstr);' ...
             '   end;' ...
             'end;' ...
             'clear tmps tmpv tmpstr tmpfieldnames;' ];

	% popup window parameters
	% -----------------------
   geometry = { [1 1 1 1 0.2] ... % Datasets
                [1 1 1 1 0.2] ... % Cross-Avg 1
                [1 1 1 1 0.2] ... % Cross-Avg 2
                [1] ...           % empty
                [1 1 1 1 0.2] ... % Channels
                [1] ...           % empty
                [1] ...           % Markers Headline
                [1 1 1 1 0.2] ... % Markers
                [1] ...           % empty
                [1 1 1 1 0.2] ... % Regularization 1
                [1 1 1 1 0.2] ... % Reg 2
                [1] ...           % empty
                [1 1 1 1 0.2] ... % Linkage 1
                [1 1 1 1 0.2] ... % Linkage 2
                [1 1 1 1 0.2] ... % Linkage 3
                [1] ...           % empty
                [1 1 1 1 0.2] ... % Distance 1
                [1 1 1 1 0.2] ... % Distance 2
                [1 1 1 1 0.2] ... % Distance 3
                [1 1 1 1 0.2] ... % Distance 3.1
                [1 1 1 1 0.2] ... % Distance 3.2
                [1 1 1 1 0.2] ... % Distance 3.3
                [1 1 1 1 0.2] ... % Distance 3.4
                [1 1 1 1 0.2] ... % Distance 3.5
                [1 1 1 1 0.2] ... % Distance 3.6
                [1 1 1 1 0.2] ... % Distance 3.7
                [1] ...           % empty
                [1 1 1 1 0.2] ... % progress bar
              };
   
   uilist = { ...
       { 'style' 'text' 'string' 'Datasets ([]=current):' 'fontweight', 'bold' } ...
       { 'style' 'edit' 'string' '' } ...       
       { 'style' 'checkbox' 'tag' 'overwrite' 'string' 'Overwrite Previous PADTW' 'value' 1 }...
       { 'style' 'text' 'string' '(that has been computed earlier)'} {} ...
       {} { 'style' 'checkbox' 'string' 'Calculate Cross-Dataset PADTW' 'value' 0 'callback'...
         [ ...
             'set(findobj(''parent'', gcbf, ''tag'', ''crossavg''),'...
             ' ''enable'', fastif(get(gcbo, ''value''), ''on'', ''off''));' ... 
             'set(findobj(''parent'', gcbf, ''tag'', ''crosspadtw''),'...
             ' ''enable'', fastif(get(gcbo, ''value''), ''on'', ''off''));' ... 
         ] ...
       }...
       { 'style' 'checkbox' 'tag' 'crossavg' 'string' '... on the basis of average' ...
         'enable' 'off' 'value' 0 'callback' ...
         [ ...
             'set(findobj(''parent'', gcbf, ''tag'', ''crosspadtw''),'...
             ' ''value'', ~get(gcbo, ''value''));'  ...
         ] ...
       }...
       {} {} ...
       {} {} ...
       { 'style' 'checkbox' 'tag' 'crosspadtw' 'string' '... on the basis of padtw' ...
         'enable' 'off' 'value' 0 'callback' ...
         [ ... 
             'set(findobj(''parent'', gcbf, ''tag'', ''crossavg''),'...
             ' ''value'', ~get(gcbo, ''value''));'  ...             
         ] ...
       }...
       {} {} ...
       ...
       {} ...
       ...
       { 'style' 'text' 'string' 'Channels ([]=all):' 'fontweight', 'bold' } ...
       { 'style' 'edit' 'string' '' } ...       
       {} {} {} ...
       ...
       {} ...
       ...
       { 'style' 'text' 'string' 'Markers:' 'fontweight', 'bold'} ...
       ...
       { 'style' 'text' 'string' 'Number of Markers:'} ...
       { 'style' 'edit' 'string' '' } ...        
       { 'style' 'text' 'string' 'Response-Marker(s):' } ...
       { 'style' 'edit' 'string' '' 'tag' 'response_events' } ...  
       { 'style' 'pushbutton' 'string' '...' 'callback' cbevent } ...
       ...
       {} ...
       ...
       { 'style' 'text' 'string' 'Regularization:' 'fontweight', 'bold' } ...
       { 'style' 'checkbox' 'tag' 'regnone' 'string' 'None' 'value' 1 ...
       'callback'...
         [ 'set(findobj(''parent'', gcbf, ''tag'', ''reggauss''),'...
           ' ''value'', ~get(gcbo,''value''));' ...
           'set(findobj(''parent'', gcbf, ''tag'', ''sigma''),'...
           ' ''enable'', fastif(~get(gcbo, ''value''), ''on'', ''off''));' ...
         ] } ...
       {} {} {} ...
       {} { 'style' 'checkbox' 'tag' 'reggauss' 'string' 'Gaussian (Marker based)' ...
         'value' 0 'callback'...
         [ 'set(findobj(''parent'', gcbf, ''tag'', ''regnone''),'...
           ' ''value'', ~get(gcbo, ''value''));'  ...
           'set(findobj(''parent'', gcbf, ''tag'', ''sigma''),'...
           ' ''enable'', fastif(get(gcbo, ''value''), ''on'', ''off''));'...
         ] ...
       } ...
       { 'style' 'text' 'string' 'sigma' } ...
       { 'style' 'edit' 'tag' 'sigma' 'string' '' 'enable' 'off' } ...               
       {}...
       ...
       {} ...
       ...
       { 'style' 'text' 'string' 'Linkage:' 'fontweight', 'bold' } ...
       { 'style' 'checkbox' 'tag' 'linksingle' 'string' 'single linkage' 'value' 1 ...
         'callback'...
         [ 'set(findobj(''parent'', gcbf, ''tag'', ''linkcomp''),'...
           ' ''value'', 0);' ...
           'set(findobj(''parent'', gcbf, ''tag'', ''linkavg''),'...
           ' ''value'', 0);' ...
         ] } ...
       {} {} {} ...
       {} { 'style' 'checkbox' 'tag' 'linkcomp' 'string' 'complete linkage' 'value' 0 ...
         'callback'...
         [ 'set(findobj(''parent'', gcbf, ''tag'', ''linksingle''),'...
           ' ''value'', 0);' ...
           'set(findobj(''parent'', gcbf, ''tag'', ''linkavg''),'...
           ' ''value'', 0);' ...
         ] } ...
       {} {} {} ...
       {} { 'style' 'checkbox' 'tag' 'linkavg' 'string' 'average linkage' 'value' 0 ...
         'callback'...
         [ 'set(findobj(''parent'', gcbf, ''tag'', ''linkcomp''),'...
           ' ''value'', 0);' ...
           'set(findobj(''parent'', gcbf, ''tag'', ''linksingle''),'...
           ' ''value'', 0);' ...
         ] } ...
       {} {} {} ...
       ...
       {} ...
       ...
       { 'style' 'text' 'string' 'Distance Metric:' 'fontweight', 'bold' } ...
       { 'style' 'checkbox' 'tag' 'disteuclid' 'string' 'Euclidean' 'value' 0 ...
         'callback'...
         [ 'set(findobj(''parent'', gcbf, ''tag'', ''distderiv''),'...
           ' ''value'', 0);' ...
           'set(findobj(''parent'', gcbf, ''tag'', ''diststft''),'...
           ' ''value'', 0);' ...
         ] } ...
       {} {} {} ...
       {} { 'style' 'checkbox' 'tag' 'distderiv' 'string' 'Euclidean Derivative' 'value' 0 ...
            'callback'...
            [ 'set(findobj(''parent'', gcbf, ''tag'', ''disteuclid''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''diststft''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''theta''),'...
              ' ''enable'', fastif(get(gcbo, ''value''), ''on'', ''off''));' ...
            ] } ...
       { 'style' 'text' 'string' 'theta' 'HorizontalAlignment' 'right' } ...
       { 'style' 'edit' 'tag' 'theta' 'string' '' 'enable' 'off' } ...               
       {} ...
       {} { 'style' 'checkbox' 'tag' 'diststft' 'string' 'Time-Frequency' 'value' 0 ...
            'callback'...
            [ 'set(findobj(''parent'', gcbf, ''tag'', ''disteuclid''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''distderiv''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''cfreqs''),'...
              ' ''enable'', fastif(get(gcbo, ''value''), ''on'', ''off''));' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''nfreqs''),'...
              ' ''enable'', fastif(get(gcbo, ''value''), ''on'', ''off''));' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''ntimes''),'...
              ' ''enable'', fastif(get(gcbo, ''value''), ''on'', ''off''));' ...
         ] } ...
       { 'style' 'text' 'string' 'Corner-Frequencies' 'HorizontalAlignment' 'right' } ...
       { 'style' 'edit' 'tag' 'cfreqs' 'string' '' 'enable' 'off' } ...               
       {} {} {} ...
       { 'style' 'text' 'string' 'Window-Function' 'HorizontalAlignment' 'right' } ...
       { 'style' 'checkbox' 'tag' 'windirich' 'string' 'Dirichlet' 'value' 0 ...
            'callback'...
            [ 'set(findobj(''parent'', gcbf, ''tag'', ''winkaiser''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''wingauss''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''winhamm''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''winhann''),'...
              ' ''value'', 0);' ...
         ] } {} ...
       {} {} {} ...
       { 'style' 'checkbox' 'tag' 'wingauss' 'string' 'Gaussian' 'value' 0 ...
            'callback'...
            [ 'set(findobj(''parent'', gcbf, ''tag'', ''winkaiser''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''windirich''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''winhamm''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''winhann''),'...
              ' ''value'', 0);' ...
         ] } {} ...
       {} {} {} ...
       { 'style' 'checkbox' 'tag' 'winhamm' 'string' 'Hamming' 'value' 0 ...
            'callback'...
            [ 'set(findobj(''parent'', gcbf, ''tag'', ''winkaiser''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''wingauss''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''windirich''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''winhann''),'...
              ' ''value'', 0);' ...
         ] } {} ...
       {} {} {}...
       { 'style' 'checkbox' 'tag' 'winhann' 'string' 'Hanning' 'value' 0 ...
            'callback'...
            [ 'set(findobj(''parent'', gcbf, ''tag'', ''winkaiser''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''wingauss''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''winhamm''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''windirich''),'...
              ' ''value'', 0);' ...
         ] } {} ...
       {} {} {}...
       { 'style' 'checkbox' 'tag' 'winkaiser' 'string' 'Kaiser' 'value' 0 ...
            'callback'...
            [ 'set(findobj(''parent'', gcbf, ''tag'', ''windirich''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''wingauss''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''winhamm''),'...
              ' ''value'', 0);' ...
              'set(findobj(''parent'', gcbf, ''tag'', ''winhann''),'...
              ' ''value'', 0);' ...
         ] } {} ...       
       {} {} ...
       { 'style' 'text' 'string' 'Frequency-Resolution (num)' 'HorizontalAlignment' 'right' } ...
       { 'style' 'edit' 'tag' 'nfreqs' 'string' '' 'enable' 'off' } ...               
       {} ...
       {} {} ...
       { 'style' 'text' 'string' 'Time-Resolution (num)' 'HorizontalAlignment' 'right' } ...
       { 'style' 'edit' 'tag' 'ntimes' 'string' '' 'enable' 'off' } ...               
       {}...
       ...
       {}...
       ...
       { 'style' 'text' 'string' 'Show Progressbar:' 'fontweight', 'bold' } ...
       { 'style' 'checkbox' 'tag' 'progress' 'value' 1}...
       {} {} {} ...
     };

   
   result = inputgui( 'geometry', geometry, 'uilist', uilist, 'title', ...
                      'Hierarchical DTW-Averaging (PADTW) -- pop_padtw()', ...
                      'helpcom', 'pophelp(''pop_padtw'')');    
   if isempty(result), return; end;
   
   % datasets
   g.datasets = eval(sprintf('[ %s ]', result{1}));
   if isempty(g.datasets), g.datasets = []; end;
   
   % overwrite?
   g.overwrite = result{2};
   
   % cross-padtw
   if result{3}
     if result{4}
       g.crosspadtw = 'avg';
     elseif result{5}
       g.crosspadtw = 'padtw';
     end;
   end;
   
   % channels
   g.chans = eval(sprintf('[ %s ]', result{6}));
   if isempty(g.chans), g.chans = 1:EEG.nbchan; end;
   
   % num_markers
   if isempty(result{7})
     g.num_markers = 0;
   else 
     g.num_markers =  eval(result{7});
   end;
   
   % list of valid markers
   if isempty(result{8})
     g.markerlist={};
   else
     g.markerlist=eval(sprintf('{ %s }', result{8}) );
   end;
   
   % Regularization
   if result{9}
     g.regularize='none';
   elseif result{10}
     g.regularize='gaussian_markers';
     g.sigma=eval(result{11});
   end;
   
   % Linkage
   if result{12}
     g.linkage='single';
   elseif result{13}
     g.linkage='complete';
   elseif result{14}
     g.linkage='average';
   end;
   
   % Distance
   if result{15}
     g.pointdistance='euclidean';
   elseif result{16}
     g.pointdistance='euclidean_derivative';
     if isempty(result{17})
       g.theta=[1 1];
     else
       g.theta=eval(sprintf('[ %s ]', result{17}));
       if size(g.theta,2)<2
         g.theta = [g.theta g.theta];
       end;
     end;
   elseif result{18}
     g.pointdistance='stft';
     if isempty(result{19})
       g.corner_freqs=[0 EEG.points/2];
     else
       g.corner_freqs=eval(sprintf('[ %s ]', result{19}));
       if size(g.corner_freqs,2)<2
         g.corner_freqs=[0 EEG.points/2];
       end;
     end;
     if result{20}
       g.windowfct='dirichlet';
     elseif result{21}
       g.windowfct='gaussian';
     elseif result{22}
       g.windowfct='hamming';
     elseif result{23}
       g.windowfct='hanning';
     elseif result{24}
       g.windowfct='kaiser';
     end; 
     if isempty(result{25})
       g.N_freq=10;
     else
       g.N_freq=eval(result{25});
     end;
     if isempty(result{26})
       g.N_time=10;
     else
       g.N_time=eval(result{26});
     end;
   end;  
   
   % Progressbar
   if result{27}
     g.progress=1;
   else 
     g.progress=0;
   end;
end;

%% ------------------------------------------------------------------

if isempty(g.datasets)
  use_EEGs=[EEG]; 
else
  try
    ALLEEG(g.datasets);
  catch
    disp('Sorry, at least one of the datasets: ');
    disp(g.datasets);
    disp(' does not exist');
    return;
  end;
  use_EEGs=[ALLEEG(g.datasets)];
end;

if ~g.crosspadtw %% calculate the PADTW for single datasets
  for CEEG=use_EEGs
    disp(CEEG);
    [electrodes samples trials] = size(CEEG.data);
    zero_idx = closest( CEEG.times, 0 );

    markers = [];
    for i=1:trials
      ev = CEEG.epoch(i).eventtype(:);
      eventlist=[];
      for s=1:size(ev,1) % get matches
        marker = find_str_in_cellstr( g.markerlist, ev{s} );
        if marker~=0
          eventlist = [eventlist s];
        end;
      end;
      
      try
        markers = [markers; eventlist(1:g.num_markers)];
      catch
        disp( sprintf( 'pop_padtw(): one of the trials does not contain enough markers, trial no. %i', i ) ); 
        return;
      end;
      
      for j=1:g.num_markers
        m = markers(end,j);
        tmp = CEEG.epoch(i).eventlatency(m);
        markers(end,j) = closest(CEEG.times, tmp{:});
      end;
    end;
    
    if ~isfield(CEEG, 'padtw') | g.overwrite
      [padtw, new_markers] = ml_padtw( double(CEEG.data(g.chans,:,:)), markers, g );
      CEEG.padtw=padtw;
      CEEG.padtw_markers=new_markers;
      CEEG.padtw_settings = g;
    end;
  end;

elseif g.crosspadtw % calculate cross-padtw 
  if g.crosspadtw~='avg' & g.crosspadtw~='padtw'
    disp(sprintf('Sorry, no method implemented for cross-PADTW "%s"', ...
                 g.crosspadtw))
    return;
  end;
  data = [];
  markers = [];
  if g.crosspadtw=='avg'
    for i=max(size(use_EEGs))
      CEEG=use_EEGs(i);
      d = reshape( mean( CEEG.data(g.chans,:,:), 2 ), [ ...
          size(CEEG.data(g.chans,:,:), 1) size(CEEG.data(g.chans,:,:), 3)]);
      data(:,i,:) = d;
    end;
  elseif g.crosspadtw=='padtw'
    
  end;
  
  [padtw, new_markers] = ml_padtw( double(data), markers, g );
end;
  
  
% return the string command
% -------------------------

return;